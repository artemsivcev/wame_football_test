// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'statistics_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

Statistics _$StatisticsFromJson(Map<String, dynamic> json) {
  return _Statistics.fromJson(json);
}

/// @nodoc
mixin _$Statistics {
  Cards get cards => throw _privateConstructorUsedError;
  Duels get duels => throw _privateConstructorUsedError;
  Fouls get fouls => throw _privateConstructorUsedError;
  Games get games => throw _privateConstructorUsedError;
  Goals get goals => throw _privateConstructorUsedError;
  League get league => throw _privateConstructorUsedError;
  Passes get passes => throw _privateConstructorUsedError;
  Penalty get penalty => throw _privateConstructorUsedError;
  Shots get shots => throw _privateConstructorUsedError;
  Tackles get tackles => throw _privateConstructorUsedError;
  Team get team => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $StatisticsCopyWith<Statistics> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StatisticsCopyWith<$Res> {
  factory $StatisticsCopyWith(
          Statistics value, $Res Function(Statistics) then) =
      _$StatisticsCopyWithImpl<$Res, Statistics>;
  @useResult
  $Res call(
      {Cards cards,
      Duels duels,
      Fouls fouls,
      Games games,
      Goals goals,
      League league,
      Passes passes,
      Penalty penalty,
      Shots shots,
      Tackles tackles,
      Team team});

  $CardsCopyWith<$Res> get cards;
  $DuelsCopyWith<$Res> get duels;
  $FoulsCopyWith<$Res> get fouls;
  $GamesCopyWith<$Res> get games;
  $GoalsCopyWith<$Res> get goals;
  $LeagueCopyWith<$Res> get league;
  $PassesCopyWith<$Res> get passes;
  $PenaltyCopyWith<$Res> get penalty;
  $ShotsCopyWith<$Res> get shots;
  $TacklesCopyWith<$Res> get tackles;
  $TeamCopyWith<$Res> get team;
}

/// @nodoc
class _$StatisticsCopyWithImpl<$Res, $Val extends Statistics>
    implements $StatisticsCopyWith<$Res> {
  _$StatisticsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cards = null,
    Object? duels = null,
    Object? fouls = null,
    Object? games = null,
    Object? goals = null,
    Object? league = null,
    Object? passes = null,
    Object? penalty = null,
    Object? shots = null,
    Object? tackles = null,
    Object? team = null,
  }) {
    return _then(_value.copyWith(
      cards: null == cards
          ? _value.cards
          : cards // ignore: cast_nullable_to_non_nullable
              as Cards,
      duels: null == duels
          ? _value.duels
          : duels // ignore: cast_nullable_to_non_nullable
              as Duels,
      fouls: null == fouls
          ? _value.fouls
          : fouls // ignore: cast_nullable_to_non_nullable
              as Fouls,
      games: null == games
          ? _value.games
          : games // ignore: cast_nullable_to_non_nullable
              as Games,
      goals: null == goals
          ? _value.goals
          : goals // ignore: cast_nullable_to_non_nullable
              as Goals,
      league: null == league
          ? _value.league
          : league // ignore: cast_nullable_to_non_nullable
              as League,
      passes: null == passes
          ? _value.passes
          : passes // ignore: cast_nullable_to_non_nullable
              as Passes,
      penalty: null == penalty
          ? _value.penalty
          : penalty // ignore: cast_nullable_to_non_nullable
              as Penalty,
      shots: null == shots
          ? _value.shots
          : shots // ignore: cast_nullable_to_non_nullable
              as Shots,
      tackles: null == tackles
          ? _value.tackles
          : tackles // ignore: cast_nullable_to_non_nullable
              as Tackles,
      team: null == team
          ? _value.team
          : team // ignore: cast_nullable_to_non_nullable
              as Team,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CardsCopyWith<$Res> get cards {
    return $CardsCopyWith<$Res>(_value.cards, (value) {
      return _then(_value.copyWith(cards: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $DuelsCopyWith<$Res> get duels {
    return $DuelsCopyWith<$Res>(_value.duels, (value) {
      return _then(_value.copyWith(duels: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FoulsCopyWith<$Res> get fouls {
    return $FoulsCopyWith<$Res>(_value.fouls, (value) {
      return _then(_value.copyWith(fouls: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $GamesCopyWith<$Res> get games {
    return $GamesCopyWith<$Res>(_value.games, (value) {
      return _then(_value.copyWith(games: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $GoalsCopyWith<$Res> get goals {
    return $GoalsCopyWith<$Res>(_value.goals, (value) {
      return _then(_value.copyWith(goals: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $LeagueCopyWith<$Res> get league {
    return $LeagueCopyWith<$Res>(_value.league, (value) {
      return _then(_value.copyWith(league: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PassesCopyWith<$Res> get passes {
    return $PassesCopyWith<$Res>(_value.passes, (value) {
      return _then(_value.copyWith(passes: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PenaltyCopyWith<$Res> get penalty {
    return $PenaltyCopyWith<$Res>(_value.penalty, (value) {
      return _then(_value.copyWith(penalty: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ShotsCopyWith<$Res> get shots {
    return $ShotsCopyWith<$Res>(_value.shots, (value) {
      return _then(_value.copyWith(shots: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TacklesCopyWith<$Res> get tackles {
    return $TacklesCopyWith<$Res>(_value.tackles, (value) {
      return _then(_value.copyWith(tackles: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TeamCopyWith<$Res> get team {
    return $TeamCopyWith<$Res>(_value.team, (value) {
      return _then(_value.copyWith(team: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$StatisticsImplCopyWith<$Res>
    implements $StatisticsCopyWith<$Res> {
  factory _$$StatisticsImplCopyWith(
          _$StatisticsImpl value, $Res Function(_$StatisticsImpl) then) =
      __$$StatisticsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Cards cards,
      Duels duels,
      Fouls fouls,
      Games games,
      Goals goals,
      League league,
      Passes passes,
      Penalty penalty,
      Shots shots,
      Tackles tackles,
      Team team});

  @override
  $CardsCopyWith<$Res> get cards;
  @override
  $DuelsCopyWith<$Res> get duels;
  @override
  $FoulsCopyWith<$Res> get fouls;
  @override
  $GamesCopyWith<$Res> get games;
  @override
  $GoalsCopyWith<$Res> get goals;
  @override
  $LeagueCopyWith<$Res> get league;
  @override
  $PassesCopyWith<$Res> get passes;
  @override
  $PenaltyCopyWith<$Res> get penalty;
  @override
  $ShotsCopyWith<$Res> get shots;
  @override
  $TacklesCopyWith<$Res> get tackles;
  @override
  $TeamCopyWith<$Res> get team;
}

/// @nodoc
class __$$StatisticsImplCopyWithImpl<$Res>
    extends _$StatisticsCopyWithImpl<$Res, _$StatisticsImpl>
    implements _$$StatisticsImplCopyWith<$Res> {
  __$$StatisticsImplCopyWithImpl(
      _$StatisticsImpl _value, $Res Function(_$StatisticsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cards = null,
    Object? duels = null,
    Object? fouls = null,
    Object? games = null,
    Object? goals = null,
    Object? league = null,
    Object? passes = null,
    Object? penalty = null,
    Object? shots = null,
    Object? tackles = null,
    Object? team = null,
  }) {
    return _then(_$StatisticsImpl(
      cards: null == cards
          ? _value.cards
          : cards // ignore: cast_nullable_to_non_nullable
              as Cards,
      duels: null == duels
          ? _value.duels
          : duels // ignore: cast_nullable_to_non_nullable
              as Duels,
      fouls: null == fouls
          ? _value.fouls
          : fouls // ignore: cast_nullable_to_non_nullable
              as Fouls,
      games: null == games
          ? _value.games
          : games // ignore: cast_nullable_to_non_nullable
              as Games,
      goals: null == goals
          ? _value.goals
          : goals // ignore: cast_nullable_to_non_nullable
              as Goals,
      league: null == league
          ? _value.league
          : league // ignore: cast_nullable_to_non_nullable
              as League,
      passes: null == passes
          ? _value.passes
          : passes // ignore: cast_nullable_to_non_nullable
              as Passes,
      penalty: null == penalty
          ? _value.penalty
          : penalty // ignore: cast_nullable_to_non_nullable
              as Penalty,
      shots: null == shots
          ? _value.shots
          : shots // ignore: cast_nullable_to_non_nullable
              as Shots,
      tackles: null == tackles
          ? _value.tackles
          : tackles // ignore: cast_nullable_to_non_nullable
              as Tackles,
      team: null == team
          ? _value.team
          : team // ignore: cast_nullable_to_non_nullable
              as Team,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$StatisticsImpl implements _Statistics {
  _$StatisticsImpl(
      {required this.cards,
      required this.duels,
      required this.fouls,
      required this.games,
      required this.goals,
      required this.league,
      required this.passes,
      required this.penalty,
      required this.shots,
      required this.tackles,
      required this.team});

  factory _$StatisticsImpl.fromJson(Map<String, dynamic> json) =>
      _$$StatisticsImplFromJson(json);

  @override
  final Cards cards;
  @override
  final Duels duels;
  @override
  final Fouls fouls;
  @override
  final Games games;
  @override
  final Goals goals;
  @override
  final League league;
  @override
  final Passes passes;
  @override
  final Penalty penalty;
  @override
  final Shots shots;
  @override
  final Tackles tackles;
  @override
  final Team team;

  @override
  String toString() {
    return 'Statistics(cards: $cards, duels: $duels, fouls: $fouls, games: $games, goals: $goals, league: $league, passes: $passes, penalty: $penalty, shots: $shots, tackles: $tackles, team: $team)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StatisticsImpl &&
            (identical(other.cards, cards) || other.cards == cards) &&
            (identical(other.duels, duels) || other.duels == duels) &&
            (identical(other.fouls, fouls) || other.fouls == fouls) &&
            (identical(other.games, games) || other.games == games) &&
            (identical(other.goals, goals) || other.goals == goals) &&
            (identical(other.league, league) || other.league == league) &&
            (identical(other.passes, passes) || other.passes == passes) &&
            (identical(other.penalty, penalty) || other.penalty == penalty) &&
            (identical(other.shots, shots) || other.shots == shots) &&
            (identical(other.tackles, tackles) || other.tackles == tackles) &&
            (identical(other.team, team) || other.team == team));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, cards, duels, fouls, games,
      goals, league, passes, penalty, shots, tackles, team);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StatisticsImplCopyWith<_$StatisticsImpl> get copyWith =>
      __$$StatisticsImplCopyWithImpl<_$StatisticsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$StatisticsImplToJson(
      this,
    );
  }
}

abstract class _Statistics implements Statistics {
  factory _Statistics(
      {required final Cards cards,
      required final Duels duels,
      required final Fouls fouls,
      required final Games games,
      required final Goals goals,
      required final League league,
      required final Passes passes,
      required final Penalty penalty,
      required final Shots shots,
      required final Tackles tackles,
      required final Team team}) = _$StatisticsImpl;

  factory _Statistics.fromJson(Map<String, dynamic> json) =
      _$StatisticsImpl.fromJson;

  @override
  Cards get cards;
  @override
  Duels get duels;
  @override
  Fouls get fouls;
  @override
  Games get games;
  @override
  Goals get goals;
  @override
  League get league;
  @override
  Passes get passes;
  @override
  Penalty get penalty;
  @override
  Shots get shots;
  @override
  Tackles get tackles;
  @override
  Team get team;
  @override
  @JsonKey(ignore: true)
  _$$StatisticsImplCopyWith<_$StatisticsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Cards _$CardsFromJson(Map<String, dynamic> json) {
  return _Cards.fromJson(json);
}

/// @nodoc
mixin _$Cards {
  int get red => throw _privateConstructorUsedError;
  int get yellow => throw _privateConstructorUsedError;
  int get yellowred => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CardsCopyWith<Cards> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CardsCopyWith<$Res> {
  factory $CardsCopyWith(Cards value, $Res Function(Cards) then) =
      _$CardsCopyWithImpl<$Res, Cards>;
  @useResult
  $Res call({int red, int yellow, int yellowred});
}

/// @nodoc
class _$CardsCopyWithImpl<$Res, $Val extends Cards>
    implements $CardsCopyWith<$Res> {
  _$CardsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? red = null,
    Object? yellow = null,
    Object? yellowred = null,
  }) {
    return _then(_value.copyWith(
      red: null == red
          ? _value.red
          : red // ignore: cast_nullable_to_non_nullable
              as int,
      yellow: null == yellow
          ? _value.yellow
          : yellow // ignore: cast_nullable_to_non_nullable
              as int,
      yellowred: null == yellowred
          ? _value.yellowred
          : yellowred // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CardsImplCopyWith<$Res> implements $CardsCopyWith<$Res> {
  factory _$$CardsImplCopyWith(
          _$CardsImpl value, $Res Function(_$CardsImpl) then) =
      __$$CardsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int red, int yellow, int yellowred});
}

/// @nodoc
class __$$CardsImplCopyWithImpl<$Res>
    extends _$CardsCopyWithImpl<$Res, _$CardsImpl>
    implements _$$CardsImplCopyWith<$Res> {
  __$$CardsImplCopyWithImpl(
      _$CardsImpl _value, $Res Function(_$CardsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? red = null,
    Object? yellow = null,
    Object? yellowred = null,
  }) {
    return _then(_$CardsImpl(
      red: null == red
          ? _value.red
          : red // ignore: cast_nullable_to_non_nullable
              as int,
      yellow: null == yellow
          ? _value.yellow
          : yellow // ignore: cast_nullable_to_non_nullable
              as int,
      yellowred: null == yellowred
          ? _value.yellowred
          : yellowred // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CardsImpl implements _Cards {
  _$CardsImpl(
      {required this.red, required this.yellow, required this.yellowred});

  factory _$CardsImpl.fromJson(Map<String, dynamic> json) =>
      _$$CardsImplFromJson(json);

  @override
  final int red;
  @override
  final int yellow;
  @override
  final int yellowred;

  @override
  String toString() {
    return 'Cards(red: $red, yellow: $yellow, yellowred: $yellowred)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CardsImpl &&
            (identical(other.red, red) || other.red == red) &&
            (identical(other.yellow, yellow) || other.yellow == yellow) &&
            (identical(other.yellowred, yellowred) ||
                other.yellowred == yellowred));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, red, yellow, yellowred);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CardsImplCopyWith<_$CardsImpl> get copyWith =>
      __$$CardsImplCopyWithImpl<_$CardsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CardsImplToJson(
      this,
    );
  }
}

abstract class _Cards implements Cards {
  factory _Cards(
      {required final int red,
      required final int yellow,
      required final int yellowred}) = _$CardsImpl;

  factory _Cards.fromJson(Map<String, dynamic> json) = _$CardsImpl.fromJson;

  @override
  int get red;
  @override
  int get yellow;
  @override
  int get yellowred;
  @override
  @JsonKey(ignore: true)
  _$$CardsImplCopyWith<_$CardsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Duels _$DuelsFromJson(Map<String, dynamic> json) {
  return _Duels.fromJson(json);
}

/// @nodoc
mixin _$Duels {
  int get total => throw _privateConstructorUsedError;
  int get won => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DuelsCopyWith<Duels> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DuelsCopyWith<$Res> {
  factory $DuelsCopyWith(Duels value, $Res Function(Duels) then) =
      _$DuelsCopyWithImpl<$Res, Duels>;
  @useResult
  $Res call({int total, int won});
}

/// @nodoc
class _$DuelsCopyWithImpl<$Res, $Val extends Duels>
    implements $DuelsCopyWith<$Res> {
  _$DuelsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? total = null,
    Object? won = null,
  }) {
    return _then(_value.copyWith(
      total: null == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
      won: null == won
          ? _value.won
          : won // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DuelsImplCopyWith<$Res> implements $DuelsCopyWith<$Res> {
  factory _$$DuelsImplCopyWith(
          _$DuelsImpl value, $Res Function(_$DuelsImpl) then) =
      __$$DuelsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int total, int won});
}

/// @nodoc
class __$$DuelsImplCopyWithImpl<$Res>
    extends _$DuelsCopyWithImpl<$Res, _$DuelsImpl>
    implements _$$DuelsImplCopyWith<$Res> {
  __$$DuelsImplCopyWithImpl(
      _$DuelsImpl _value, $Res Function(_$DuelsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? total = null,
    Object? won = null,
  }) {
    return _then(_$DuelsImpl(
      total: null == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
      won: null == won
          ? _value.won
          : won // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DuelsImpl implements _Duels {
  _$DuelsImpl({required this.total, required this.won});

  factory _$DuelsImpl.fromJson(Map<String, dynamic> json) =>
      _$$DuelsImplFromJson(json);

  @override
  final int total;
  @override
  final int won;

  @override
  String toString() {
    return 'Duels(total: $total, won: $won)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DuelsImpl &&
            (identical(other.total, total) || other.total == total) &&
            (identical(other.won, won) || other.won == won));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, total, won);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DuelsImplCopyWith<_$DuelsImpl> get copyWith =>
      __$$DuelsImplCopyWithImpl<_$DuelsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DuelsImplToJson(
      this,
    );
  }
}

abstract class _Duels implements Duels {
  factory _Duels({required final int total, required final int won}) =
      _$DuelsImpl;

  factory _Duels.fromJson(Map<String, dynamic> json) = _$DuelsImpl.fromJson;

  @override
  int get total;
  @override
  int get won;
  @override
  @JsonKey(ignore: true)
  _$$DuelsImplCopyWith<_$DuelsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Fouls _$FoulsFromJson(Map<String, dynamic> json) {
  return _Fouls.fromJson(json);
}

/// @nodoc
mixin _$Fouls {
  int? get committed => throw _privateConstructorUsedError;
  int? get drawn => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FoulsCopyWith<Fouls> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FoulsCopyWith<$Res> {
  factory $FoulsCopyWith(Fouls value, $Res Function(Fouls) then) =
      _$FoulsCopyWithImpl<$Res, Fouls>;
  @useResult
  $Res call({int? committed, int? drawn});
}

/// @nodoc
class _$FoulsCopyWithImpl<$Res, $Val extends Fouls>
    implements $FoulsCopyWith<$Res> {
  _$FoulsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? committed = freezed,
    Object? drawn = freezed,
  }) {
    return _then(_value.copyWith(
      committed: freezed == committed
          ? _value.committed
          : committed // ignore: cast_nullable_to_non_nullable
              as int?,
      drawn: freezed == drawn
          ? _value.drawn
          : drawn // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FoulsImplCopyWith<$Res> implements $FoulsCopyWith<$Res> {
  factory _$$FoulsImplCopyWith(
          _$FoulsImpl value, $Res Function(_$FoulsImpl) then) =
      __$$FoulsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? committed, int? drawn});
}

/// @nodoc
class __$$FoulsImplCopyWithImpl<$Res>
    extends _$FoulsCopyWithImpl<$Res, _$FoulsImpl>
    implements _$$FoulsImplCopyWith<$Res> {
  __$$FoulsImplCopyWithImpl(
      _$FoulsImpl _value, $Res Function(_$FoulsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? committed = freezed,
    Object? drawn = freezed,
  }) {
    return _then(_$FoulsImpl(
      committed: freezed == committed
          ? _value.committed
          : committed // ignore: cast_nullable_to_non_nullable
              as int?,
      drawn: freezed == drawn
          ? _value.drawn
          : drawn // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FoulsImpl implements _Fouls {
  _$FoulsImpl({required this.committed, required this.drawn});

  factory _$FoulsImpl.fromJson(Map<String, dynamic> json) =>
      _$$FoulsImplFromJson(json);

  @override
  final int? committed;
  @override
  final int? drawn;

  @override
  String toString() {
    return 'Fouls(committed: $committed, drawn: $drawn)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FoulsImpl &&
            (identical(other.committed, committed) ||
                other.committed == committed) &&
            (identical(other.drawn, drawn) || other.drawn == drawn));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, committed, drawn);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FoulsImplCopyWith<_$FoulsImpl> get copyWith =>
      __$$FoulsImplCopyWithImpl<_$FoulsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FoulsImplToJson(
      this,
    );
  }
}

abstract class _Fouls implements Fouls {
  factory _Fouls({required final int? committed, required final int? drawn}) =
      _$FoulsImpl;

  factory _Fouls.fromJson(Map<String, dynamic> json) = _$FoulsImpl.fromJson;

  @override
  int? get committed;
  @override
  int? get drawn;
  @override
  @JsonKey(ignore: true)
  _$$FoulsImplCopyWith<_$FoulsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Games _$GamesFromJson(Map<String, dynamic> json) {
  return _Games.fromJson(json);
}

/// @nodoc
mixin _$Games {
  int get appearences => throw _privateConstructorUsedError;
  bool get captain => throw _privateConstructorUsedError;
  int get lineups => throw _privateConstructorUsedError;
  int get minutes => throw _privateConstructorUsedError;
  String? get number => throw _privateConstructorUsedError;
  String get position => throw _privateConstructorUsedError;
  String get rating => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GamesCopyWith<Games> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GamesCopyWith<$Res> {
  factory $GamesCopyWith(Games value, $Res Function(Games) then) =
      _$GamesCopyWithImpl<$Res, Games>;
  @useResult
  $Res call(
      {int appearences,
      bool captain,
      int lineups,
      int minutes,
      String? number,
      String position,
      String rating});
}

/// @nodoc
class _$GamesCopyWithImpl<$Res, $Val extends Games>
    implements $GamesCopyWith<$Res> {
  _$GamesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? appearences = null,
    Object? captain = null,
    Object? lineups = null,
    Object? minutes = null,
    Object? number = freezed,
    Object? position = null,
    Object? rating = null,
  }) {
    return _then(_value.copyWith(
      appearences: null == appearences
          ? _value.appearences
          : appearences // ignore: cast_nullable_to_non_nullable
              as int,
      captain: null == captain
          ? _value.captain
          : captain // ignore: cast_nullable_to_non_nullable
              as bool,
      lineups: null == lineups
          ? _value.lineups
          : lineups // ignore: cast_nullable_to_non_nullable
              as int,
      minutes: null == minutes
          ? _value.minutes
          : minutes // ignore: cast_nullable_to_non_nullable
              as int,
      number: freezed == number
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as String?,
      position: null == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as String,
      rating: null == rating
          ? _value.rating
          : rating // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$GamesImplCopyWith<$Res> implements $GamesCopyWith<$Res> {
  factory _$$GamesImplCopyWith(
          _$GamesImpl value, $Res Function(_$GamesImpl) then) =
      __$$GamesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int appearences,
      bool captain,
      int lineups,
      int minutes,
      String? number,
      String position,
      String rating});
}

/// @nodoc
class __$$GamesImplCopyWithImpl<$Res>
    extends _$GamesCopyWithImpl<$Res, _$GamesImpl>
    implements _$$GamesImplCopyWith<$Res> {
  __$$GamesImplCopyWithImpl(
      _$GamesImpl _value, $Res Function(_$GamesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? appearences = null,
    Object? captain = null,
    Object? lineups = null,
    Object? minutes = null,
    Object? number = freezed,
    Object? position = null,
    Object? rating = null,
  }) {
    return _then(_$GamesImpl(
      appearences: null == appearences
          ? _value.appearences
          : appearences // ignore: cast_nullable_to_non_nullable
              as int,
      captain: null == captain
          ? _value.captain
          : captain // ignore: cast_nullable_to_non_nullable
              as bool,
      lineups: null == lineups
          ? _value.lineups
          : lineups // ignore: cast_nullable_to_non_nullable
              as int,
      minutes: null == minutes
          ? _value.minutes
          : minutes // ignore: cast_nullable_to_non_nullable
              as int,
      number: freezed == number
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as String?,
      position: null == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as String,
      rating: null == rating
          ? _value.rating
          : rating // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$GamesImpl implements _Games {
  _$GamesImpl(
      {required this.appearences,
      required this.captain,
      required this.lineups,
      required this.minutes,
      required this.number,
      required this.position,
      required this.rating});

  factory _$GamesImpl.fromJson(Map<String, dynamic> json) =>
      _$$GamesImplFromJson(json);

  @override
  final int appearences;
  @override
  final bool captain;
  @override
  final int lineups;
  @override
  final int minutes;
  @override
  final String? number;
  @override
  final String position;
  @override
  final String rating;

  @override
  String toString() {
    return 'Games(appearences: $appearences, captain: $captain, lineups: $lineups, minutes: $minutes, number: $number, position: $position, rating: $rating)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GamesImpl &&
            (identical(other.appearences, appearences) ||
                other.appearences == appearences) &&
            (identical(other.captain, captain) || other.captain == captain) &&
            (identical(other.lineups, lineups) || other.lineups == lineups) &&
            (identical(other.minutes, minutes) || other.minutes == minutes) &&
            (identical(other.number, number) || other.number == number) &&
            (identical(other.position, position) ||
                other.position == position) &&
            (identical(other.rating, rating) || other.rating == rating));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, appearences, captain, lineups,
      minutes, number, position, rating);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GamesImplCopyWith<_$GamesImpl> get copyWith =>
      __$$GamesImplCopyWithImpl<_$GamesImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$GamesImplToJson(
      this,
    );
  }
}

abstract class _Games implements Games {
  factory _Games(
      {required final int appearences,
      required final bool captain,
      required final int lineups,
      required final int minutes,
      required final String? number,
      required final String position,
      required final String rating}) = _$GamesImpl;

  factory _Games.fromJson(Map<String, dynamic> json) = _$GamesImpl.fromJson;

  @override
  int get appearences;
  @override
  bool get captain;
  @override
  int get lineups;
  @override
  int get minutes;
  @override
  String? get number;
  @override
  String get position;
  @override
  String get rating;
  @override
  @JsonKey(ignore: true)
  _$$GamesImplCopyWith<_$GamesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Goals _$GoalsFromJson(Map<String, dynamic> json) {
  return _Goals.fromJson(json);
}

/// @nodoc
mixin _$Goals {
  int? get assists => throw _privateConstructorUsedError;
  int? get conceded => throw _privateConstructorUsedError;
  int? get saves => throw _privateConstructorUsedError;
  int? get total => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GoalsCopyWith<Goals> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GoalsCopyWith<$Res> {
  factory $GoalsCopyWith(Goals value, $Res Function(Goals) then) =
      _$GoalsCopyWithImpl<$Res, Goals>;
  @useResult
  $Res call({int? assists, int? conceded, int? saves, int? total});
}

/// @nodoc
class _$GoalsCopyWithImpl<$Res, $Val extends Goals>
    implements $GoalsCopyWith<$Res> {
  _$GoalsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? assists = freezed,
    Object? conceded = freezed,
    Object? saves = freezed,
    Object? total = freezed,
  }) {
    return _then(_value.copyWith(
      assists: freezed == assists
          ? _value.assists
          : assists // ignore: cast_nullable_to_non_nullable
              as int?,
      conceded: freezed == conceded
          ? _value.conceded
          : conceded // ignore: cast_nullable_to_non_nullable
              as int?,
      saves: freezed == saves
          ? _value.saves
          : saves // ignore: cast_nullable_to_non_nullable
              as int?,
      total: freezed == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$GoalsImplCopyWith<$Res> implements $GoalsCopyWith<$Res> {
  factory _$$GoalsImplCopyWith(
          _$GoalsImpl value, $Res Function(_$GoalsImpl) then) =
      __$$GoalsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? assists, int? conceded, int? saves, int? total});
}

/// @nodoc
class __$$GoalsImplCopyWithImpl<$Res>
    extends _$GoalsCopyWithImpl<$Res, _$GoalsImpl>
    implements _$$GoalsImplCopyWith<$Res> {
  __$$GoalsImplCopyWithImpl(
      _$GoalsImpl _value, $Res Function(_$GoalsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? assists = freezed,
    Object? conceded = freezed,
    Object? saves = freezed,
    Object? total = freezed,
  }) {
    return _then(_$GoalsImpl(
      assists: freezed == assists
          ? _value.assists
          : assists // ignore: cast_nullable_to_non_nullable
              as int?,
      conceded: freezed == conceded
          ? _value.conceded
          : conceded // ignore: cast_nullable_to_non_nullable
              as int?,
      saves: freezed == saves
          ? _value.saves
          : saves // ignore: cast_nullable_to_non_nullable
              as int?,
      total: freezed == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$GoalsImpl implements _Goals {
  _$GoalsImpl(
      {required this.assists,
      required this.conceded,
      required this.saves,
      required this.total});

  factory _$GoalsImpl.fromJson(Map<String, dynamic> json) =>
      _$$GoalsImplFromJson(json);

  @override
  final int? assists;
  @override
  final int? conceded;
  @override
  final int? saves;
  @override
  final int? total;

  @override
  String toString() {
    return 'Goals(assists: $assists, conceded: $conceded, saves: $saves, total: $total)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GoalsImpl &&
            (identical(other.assists, assists) || other.assists == assists) &&
            (identical(other.conceded, conceded) ||
                other.conceded == conceded) &&
            (identical(other.saves, saves) || other.saves == saves) &&
            (identical(other.total, total) || other.total == total));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, assists, conceded, saves, total);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GoalsImplCopyWith<_$GoalsImpl> get copyWith =>
      __$$GoalsImplCopyWithImpl<_$GoalsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$GoalsImplToJson(
      this,
    );
  }
}

abstract class _Goals implements Goals {
  factory _Goals(
      {required final int? assists,
      required final int? conceded,
      required final int? saves,
      required final int? total}) = _$GoalsImpl;

  factory _Goals.fromJson(Map<String, dynamic> json) = _$GoalsImpl.fromJson;

  @override
  int? get assists;
  @override
  int? get conceded;
  @override
  int? get saves;
  @override
  int? get total;
  @override
  @JsonKey(ignore: true)
  _$$GoalsImplCopyWith<_$GoalsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

League _$LeagueFromJson(Map<String, dynamic> json) {
  return _League.fromJson(json);
}

/// @nodoc
mixin _$League {
  String get country => throw _privateConstructorUsedError;
  String? get flag => throw _privateConstructorUsedError;
  int get id => throw _privateConstructorUsedError;
  String get logo => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  int get season => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LeagueCopyWith<League> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LeagueCopyWith<$Res> {
  factory $LeagueCopyWith(League value, $Res Function(League) then) =
      _$LeagueCopyWithImpl<$Res, League>;
  @useResult
  $Res call(
      {String country,
      String? flag,
      int id,
      String logo,
      String name,
      int season});
}

/// @nodoc
class _$LeagueCopyWithImpl<$Res, $Val extends League>
    implements $LeagueCopyWith<$Res> {
  _$LeagueCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? country = null,
    Object? flag = freezed,
    Object? id = null,
    Object? logo = null,
    Object? name = null,
    Object? season = null,
  }) {
    return _then(_value.copyWith(
      country: null == country
          ? _value.country
          : country // ignore: cast_nullable_to_non_nullable
              as String,
      flag: freezed == flag
          ? _value.flag
          : flag // ignore: cast_nullable_to_non_nullable
              as String?,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      logo: null == logo
          ? _value.logo
          : logo // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      season: null == season
          ? _value.season
          : season // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LeagueImplCopyWith<$Res> implements $LeagueCopyWith<$Res> {
  factory _$$LeagueImplCopyWith(
          _$LeagueImpl value, $Res Function(_$LeagueImpl) then) =
      __$$LeagueImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String country,
      String? flag,
      int id,
      String logo,
      String name,
      int season});
}

/// @nodoc
class __$$LeagueImplCopyWithImpl<$Res>
    extends _$LeagueCopyWithImpl<$Res, _$LeagueImpl>
    implements _$$LeagueImplCopyWith<$Res> {
  __$$LeagueImplCopyWithImpl(
      _$LeagueImpl _value, $Res Function(_$LeagueImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? country = null,
    Object? flag = freezed,
    Object? id = null,
    Object? logo = null,
    Object? name = null,
    Object? season = null,
  }) {
    return _then(_$LeagueImpl(
      country: null == country
          ? _value.country
          : country // ignore: cast_nullable_to_non_nullable
              as String,
      flag: freezed == flag
          ? _value.flag
          : flag // ignore: cast_nullable_to_non_nullable
              as String?,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      logo: null == logo
          ? _value.logo
          : logo // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      season: null == season
          ? _value.season
          : season // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$LeagueImpl implements _League {
  _$LeagueImpl(
      {required this.country,
      required this.flag,
      required this.id,
      required this.logo,
      required this.name,
      required this.season});

  factory _$LeagueImpl.fromJson(Map<String, dynamic> json) =>
      _$$LeagueImplFromJson(json);

  @override
  final String country;
  @override
  final String? flag;
  @override
  final int id;
  @override
  final String logo;
  @override
  final String name;
  @override
  final int season;

  @override
  String toString() {
    return 'League(country: $country, flag: $flag, id: $id, logo: $logo, name: $name, season: $season)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LeagueImpl &&
            (identical(other.country, country) || other.country == country) &&
            (identical(other.flag, flag) || other.flag == flag) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.logo, logo) || other.logo == logo) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.season, season) || other.season == season));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, country, flag, id, logo, name, season);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LeagueImplCopyWith<_$LeagueImpl> get copyWith =>
      __$$LeagueImplCopyWithImpl<_$LeagueImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$LeagueImplToJson(
      this,
    );
  }
}

abstract class _League implements League {
  factory _League(
      {required final String country,
      required final String? flag,
      required final int id,
      required final String logo,
      required final String name,
      required final int season}) = _$LeagueImpl;

  factory _League.fromJson(Map<String, dynamic> json) = _$LeagueImpl.fromJson;

  @override
  String get country;
  @override
  String? get flag;
  @override
  int get id;
  @override
  String get logo;
  @override
  String get name;
  @override
  int get season;
  @override
  @JsonKey(ignore: true)
  _$$LeagueImplCopyWith<_$LeagueImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Passes _$PassesFromJson(Map<String, dynamic> json) {
  return _Passes.fromJson(json);
}

/// @nodoc
mixin _$Passes {
  int? get accuracy => throw _privateConstructorUsedError;
  int? get key => throw _privateConstructorUsedError;
  int? get total => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PassesCopyWith<Passes> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PassesCopyWith<$Res> {
  factory $PassesCopyWith(Passes value, $Res Function(Passes) then) =
      _$PassesCopyWithImpl<$Res, Passes>;
  @useResult
  $Res call({int? accuracy, int? key, int? total});
}

/// @nodoc
class _$PassesCopyWithImpl<$Res, $Val extends Passes>
    implements $PassesCopyWith<$Res> {
  _$PassesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? accuracy = freezed,
    Object? key = freezed,
    Object? total = freezed,
  }) {
    return _then(_value.copyWith(
      accuracy: freezed == accuracy
          ? _value.accuracy
          : accuracy // ignore: cast_nullable_to_non_nullable
              as int?,
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as int?,
      total: freezed == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PassesImplCopyWith<$Res> implements $PassesCopyWith<$Res> {
  factory _$$PassesImplCopyWith(
          _$PassesImpl value, $Res Function(_$PassesImpl) then) =
      __$$PassesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? accuracy, int? key, int? total});
}

/// @nodoc
class __$$PassesImplCopyWithImpl<$Res>
    extends _$PassesCopyWithImpl<$Res, _$PassesImpl>
    implements _$$PassesImplCopyWith<$Res> {
  __$$PassesImplCopyWithImpl(
      _$PassesImpl _value, $Res Function(_$PassesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? accuracy = freezed,
    Object? key = freezed,
    Object? total = freezed,
  }) {
    return _then(_$PassesImpl(
      accuracy: freezed == accuracy
          ? _value.accuracy
          : accuracy // ignore: cast_nullable_to_non_nullable
              as int?,
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as int?,
      total: freezed == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PassesImpl implements _Passes {
  _$PassesImpl(
      {required this.accuracy, required this.key, required this.total});

  factory _$PassesImpl.fromJson(Map<String, dynamic> json) =>
      _$$PassesImplFromJson(json);

  @override
  final int? accuracy;
  @override
  final int? key;
  @override
  final int? total;

  @override
  String toString() {
    return 'Passes(accuracy: $accuracy, key: $key, total: $total)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PassesImpl &&
            (identical(other.accuracy, accuracy) ||
                other.accuracy == accuracy) &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.total, total) || other.total == total));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, accuracy, key, total);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PassesImplCopyWith<_$PassesImpl> get copyWith =>
      __$$PassesImplCopyWithImpl<_$PassesImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PassesImplToJson(
      this,
    );
  }
}

abstract class _Passes implements Passes {
  factory _Passes(
      {required final int? accuracy,
      required final int? key,
      required final int? total}) = _$PassesImpl;

  factory _Passes.fromJson(Map<String, dynamic> json) = _$PassesImpl.fromJson;

  @override
  int? get accuracy;
  @override
  int? get key;
  @override
  int? get total;
  @override
  @JsonKey(ignore: true)
  _$$PassesImplCopyWith<_$PassesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Penalty _$PenaltyFromJson(Map<String, dynamic> json) {
  return _Penalty.fromJson(json);
}

/// @nodoc
mixin _$Penalty {
  int? get commited => throw _privateConstructorUsedError;
  int get missed => throw _privateConstructorUsedError;
  int? get saved => throw _privateConstructorUsedError;
  int get scored => throw _privateConstructorUsedError;
  int? get won => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PenaltyCopyWith<Penalty> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PenaltyCopyWith<$Res> {
  factory $PenaltyCopyWith(Penalty value, $Res Function(Penalty) then) =
      _$PenaltyCopyWithImpl<$Res, Penalty>;
  @useResult
  $Res call({int? commited, int missed, int? saved, int scored, int? won});
}

/// @nodoc
class _$PenaltyCopyWithImpl<$Res, $Val extends Penalty>
    implements $PenaltyCopyWith<$Res> {
  _$PenaltyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? commited = freezed,
    Object? missed = null,
    Object? saved = freezed,
    Object? scored = null,
    Object? won = freezed,
  }) {
    return _then(_value.copyWith(
      commited: freezed == commited
          ? _value.commited
          : commited // ignore: cast_nullable_to_non_nullable
              as int?,
      missed: null == missed
          ? _value.missed
          : missed // ignore: cast_nullable_to_non_nullable
              as int,
      saved: freezed == saved
          ? _value.saved
          : saved // ignore: cast_nullable_to_non_nullable
              as int?,
      scored: null == scored
          ? _value.scored
          : scored // ignore: cast_nullable_to_non_nullable
              as int,
      won: freezed == won
          ? _value.won
          : won // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PenaltyImplCopyWith<$Res> implements $PenaltyCopyWith<$Res> {
  factory _$$PenaltyImplCopyWith(
          _$PenaltyImpl value, $Res Function(_$PenaltyImpl) then) =
      __$$PenaltyImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? commited, int missed, int? saved, int scored, int? won});
}

/// @nodoc
class __$$PenaltyImplCopyWithImpl<$Res>
    extends _$PenaltyCopyWithImpl<$Res, _$PenaltyImpl>
    implements _$$PenaltyImplCopyWith<$Res> {
  __$$PenaltyImplCopyWithImpl(
      _$PenaltyImpl _value, $Res Function(_$PenaltyImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? commited = freezed,
    Object? missed = null,
    Object? saved = freezed,
    Object? scored = null,
    Object? won = freezed,
  }) {
    return _then(_$PenaltyImpl(
      commited: freezed == commited
          ? _value.commited
          : commited // ignore: cast_nullable_to_non_nullable
              as int?,
      missed: null == missed
          ? _value.missed
          : missed // ignore: cast_nullable_to_non_nullable
              as int,
      saved: freezed == saved
          ? _value.saved
          : saved // ignore: cast_nullable_to_non_nullable
              as int?,
      scored: null == scored
          ? _value.scored
          : scored // ignore: cast_nullable_to_non_nullable
              as int,
      won: freezed == won
          ? _value.won
          : won // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PenaltyImpl implements _Penalty {
  _$PenaltyImpl(
      {required this.commited,
      required this.missed,
      required this.saved,
      required this.scored,
      required this.won});

  factory _$PenaltyImpl.fromJson(Map<String, dynamic> json) =>
      _$$PenaltyImplFromJson(json);

  @override
  final int? commited;
  @override
  final int missed;
  @override
  final int? saved;
  @override
  final int scored;
  @override
  final int? won;

  @override
  String toString() {
    return 'Penalty(commited: $commited, missed: $missed, saved: $saved, scored: $scored, won: $won)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PenaltyImpl &&
            (identical(other.commited, commited) ||
                other.commited == commited) &&
            (identical(other.missed, missed) || other.missed == missed) &&
            (identical(other.saved, saved) || other.saved == saved) &&
            (identical(other.scored, scored) || other.scored == scored) &&
            (identical(other.won, won) || other.won == won));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, commited, missed, saved, scored, won);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PenaltyImplCopyWith<_$PenaltyImpl> get copyWith =>
      __$$PenaltyImplCopyWithImpl<_$PenaltyImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PenaltyImplToJson(
      this,
    );
  }
}

abstract class _Penalty implements Penalty {
  factory _Penalty(
      {required final int? commited,
      required final int missed,
      required final int? saved,
      required final int scored,
      required final int? won}) = _$PenaltyImpl;

  factory _Penalty.fromJson(Map<String, dynamic> json) = _$PenaltyImpl.fromJson;

  @override
  int? get commited;
  @override
  int get missed;
  @override
  int? get saved;
  @override
  int get scored;
  @override
  int? get won;
  @override
  @JsonKey(ignore: true)
  _$$PenaltyImplCopyWith<_$PenaltyImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Shots _$ShotsFromJson(Map<String, dynamic> json) {
  return _Shots.fromJson(json);
}

/// @nodoc
mixin _$Shots {
  int get on => throw _privateConstructorUsedError;
  int get total => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ShotsCopyWith<Shots> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ShotsCopyWith<$Res> {
  factory $ShotsCopyWith(Shots value, $Res Function(Shots) then) =
      _$ShotsCopyWithImpl<$Res, Shots>;
  @useResult
  $Res call({int on, int total});
}

/// @nodoc
class _$ShotsCopyWithImpl<$Res, $Val extends Shots>
    implements $ShotsCopyWith<$Res> {
  _$ShotsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? on = null,
    Object? total = null,
  }) {
    return _then(_value.copyWith(
      on: null == on
          ? _value.on
          : on // ignore: cast_nullable_to_non_nullable
              as int,
      total: null == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ShotsImplCopyWith<$Res> implements $ShotsCopyWith<$Res> {
  factory _$$ShotsImplCopyWith(
          _$ShotsImpl value, $Res Function(_$ShotsImpl) then) =
      __$$ShotsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int on, int total});
}

/// @nodoc
class __$$ShotsImplCopyWithImpl<$Res>
    extends _$ShotsCopyWithImpl<$Res, _$ShotsImpl>
    implements _$$ShotsImplCopyWith<$Res> {
  __$$ShotsImplCopyWithImpl(
      _$ShotsImpl _value, $Res Function(_$ShotsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? on = null,
    Object? total = null,
  }) {
    return _then(_$ShotsImpl(
      on: null == on
          ? _value.on
          : on // ignore: cast_nullable_to_non_nullable
              as int,
      total: null == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ShotsImpl implements _Shots {
  _$ShotsImpl({required this.on, required this.total});

  factory _$ShotsImpl.fromJson(Map<String, dynamic> json) =>
      _$$ShotsImplFromJson(json);

  @override
  final int on;
  @override
  final int total;

  @override
  String toString() {
    return 'Shots(on: $on, total: $total)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ShotsImpl &&
            (identical(other.on, on) || other.on == on) &&
            (identical(other.total, total) || other.total == total));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, on, total);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ShotsImplCopyWith<_$ShotsImpl> get copyWith =>
      __$$ShotsImplCopyWithImpl<_$ShotsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ShotsImplToJson(
      this,
    );
  }
}

abstract class _Shots implements Shots {
  factory _Shots({required final int on, required final int total}) =
      _$ShotsImpl;

  factory _Shots.fromJson(Map<String, dynamic> json) = _$ShotsImpl.fromJson;

  @override
  int get on;
  @override
  int get total;
  @override
  @JsonKey(ignore: true)
  _$$ShotsImplCopyWith<_$ShotsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Tackles _$TacklesFromJson(Map<String, dynamic> json) {
  return _Tackles.fromJson(json);
}

/// @nodoc
mixin _$Tackles {
  int? get blocks => throw _privateConstructorUsedError;
  int? get interceptions => throw _privateConstructorUsedError;
  int? get total => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TacklesCopyWith<Tackles> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TacklesCopyWith<$Res> {
  factory $TacklesCopyWith(Tackles value, $Res Function(Tackles) then) =
      _$TacklesCopyWithImpl<$Res, Tackles>;
  @useResult
  $Res call({int? blocks, int? interceptions, int? total});
}

/// @nodoc
class _$TacklesCopyWithImpl<$Res, $Val extends Tackles>
    implements $TacklesCopyWith<$Res> {
  _$TacklesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? blocks = freezed,
    Object? interceptions = freezed,
    Object? total = freezed,
  }) {
    return _then(_value.copyWith(
      blocks: freezed == blocks
          ? _value.blocks
          : blocks // ignore: cast_nullable_to_non_nullable
              as int?,
      interceptions: freezed == interceptions
          ? _value.interceptions
          : interceptions // ignore: cast_nullable_to_non_nullable
              as int?,
      total: freezed == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TacklesImplCopyWith<$Res> implements $TacklesCopyWith<$Res> {
  factory _$$TacklesImplCopyWith(
          _$TacklesImpl value, $Res Function(_$TacklesImpl) then) =
      __$$TacklesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? blocks, int? interceptions, int? total});
}

/// @nodoc
class __$$TacklesImplCopyWithImpl<$Res>
    extends _$TacklesCopyWithImpl<$Res, _$TacklesImpl>
    implements _$$TacklesImplCopyWith<$Res> {
  __$$TacklesImplCopyWithImpl(
      _$TacklesImpl _value, $Res Function(_$TacklesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? blocks = freezed,
    Object? interceptions = freezed,
    Object? total = freezed,
  }) {
    return _then(_$TacklesImpl(
      blocks: freezed == blocks
          ? _value.blocks
          : blocks // ignore: cast_nullable_to_non_nullable
              as int?,
      interceptions: freezed == interceptions
          ? _value.interceptions
          : interceptions // ignore: cast_nullable_to_non_nullable
              as int?,
      total: freezed == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TacklesImpl implements _Tackles {
  _$TacklesImpl(
      {required this.blocks, required this.interceptions, required this.total});

  factory _$TacklesImpl.fromJson(Map<String, dynamic> json) =>
      _$$TacklesImplFromJson(json);

  @override
  final int? blocks;
  @override
  final int? interceptions;
  @override
  final int? total;

  @override
  String toString() {
    return 'Tackles(blocks: $blocks, interceptions: $interceptions, total: $total)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TacklesImpl &&
            (identical(other.blocks, blocks) || other.blocks == blocks) &&
            (identical(other.interceptions, interceptions) ||
                other.interceptions == interceptions) &&
            (identical(other.total, total) || other.total == total));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, blocks, interceptions, total);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TacklesImplCopyWith<_$TacklesImpl> get copyWith =>
      __$$TacklesImplCopyWithImpl<_$TacklesImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TacklesImplToJson(
      this,
    );
  }
}

abstract class _Tackles implements Tackles {
  factory _Tackles(
      {required final int? blocks,
      required final int? interceptions,
      required final int? total}) = _$TacklesImpl;

  factory _Tackles.fromJson(Map<String, dynamic> json) = _$TacklesImpl.fromJson;

  @override
  int? get blocks;
  @override
  int? get interceptions;
  @override
  int? get total;
  @override
  @JsonKey(ignore: true)
  _$$TacklesImplCopyWith<_$TacklesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Team _$TeamFromJson(Map<String, dynamic> json) {
  return _Team.fromJson(json);
}

/// @nodoc
mixin _$Team {
  int get id => throw _privateConstructorUsedError;
  String get logo => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TeamCopyWith<Team> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TeamCopyWith<$Res> {
  factory $TeamCopyWith(Team value, $Res Function(Team) then) =
      _$TeamCopyWithImpl<$Res, Team>;
  @useResult
  $Res call({int id, String logo, String name});
}

/// @nodoc
class _$TeamCopyWithImpl<$Res, $Val extends Team>
    implements $TeamCopyWith<$Res> {
  _$TeamCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? logo = null,
    Object? name = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      logo: null == logo
          ? _value.logo
          : logo // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TeamImplCopyWith<$Res> implements $TeamCopyWith<$Res> {
  factory _$$TeamImplCopyWith(
          _$TeamImpl value, $Res Function(_$TeamImpl) then) =
      __$$TeamImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int id, String logo, String name});
}

/// @nodoc
class __$$TeamImplCopyWithImpl<$Res>
    extends _$TeamCopyWithImpl<$Res, _$TeamImpl>
    implements _$$TeamImplCopyWith<$Res> {
  __$$TeamImplCopyWithImpl(_$TeamImpl _value, $Res Function(_$TeamImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? logo = null,
    Object? name = null,
  }) {
    return _then(_$TeamImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      logo: null == logo
          ? _value.logo
          : logo // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TeamImpl implements _Team {
  _$TeamImpl({required this.id, required this.logo, required this.name});

  factory _$TeamImpl.fromJson(Map<String, dynamic> json) =>
      _$$TeamImplFromJson(json);

  @override
  final int id;
  @override
  final String logo;
  @override
  final String name;

  @override
  String toString() {
    return 'Team(id: $id, logo: $logo, name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TeamImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.logo, logo) || other.logo == logo) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, logo, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TeamImplCopyWith<_$TeamImpl> get copyWith =>
      __$$TeamImplCopyWithImpl<_$TeamImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TeamImplToJson(
      this,
    );
  }
}

abstract class _Team implements Team {
  factory _Team(
      {required final int id,
      required final String logo,
      required final String name}) = _$TeamImpl;

  factory _Team.fromJson(Map<String, dynamic> json) = _$TeamImpl.fromJson;

  @override
  int get id;
  @override
  String get logo;
  @override
  String get name;
  @override
  @JsonKey(ignore: true)
  _$$TeamImplCopyWith<_$TeamImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
